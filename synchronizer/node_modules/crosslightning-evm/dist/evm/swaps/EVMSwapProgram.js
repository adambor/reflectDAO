"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMSwapProgram = void 0;
const BN = require("bn.js");
const crypto_1 = require("crypto");
const crosslightning_base_1 = require("crosslightning-base");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const swapContract_1 = require("./contract/swapContract");
const EVMSwapData_1 = require("./EVMSwapData");
const erc20Abi_1 = require("./erc20/erc20Abi");
const utils = require("ethers/lib/utils");
const buffer_1 = require("buffer");
const STATE_SEED = "state";
const VAULT_SEED = "vault";
const USER_VAULT_SEED = "uservault";
const AUTHORITY_SEED = "authority";
const TX_DATA_SEED = "data";
const WETH_ADDRESS = "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"; //Matic WMATIC
const LOG_FETCH_LIMIT = 2500;
const GAS_CLAIM_WITH_TX_DATA_BASE = 200000;
const GAS_CLAIM_WITH_TX_DATA_PER_TX_BYTE = 100;
const GAS_CLAIM_WITH_SECRET = 150000;
const GAS_CLAIM_INIT = 150000;
const GAS_INIT = 100000;
const GAS_REFUND = 100000;
const GAS_REFUND_WITH_AUTH = 120000;
const MAX_ALLOWANCE = ethers_1.BigNumber.from("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
class EVMSwapProgram {
    static getSignatureStruct(signature, timeout) {
        const sig = utils.splitSignature(signature);
        return {
            r: sig.r,
            s: sig.s,
            vAndTimeout: ethers_1.BigNumber.from(timeout).shl(8)
                .or(ethers_1.BigNumber.from(sig.v).and(ethers_1.BigNumber.from(0xFF)))
        };
    }
    constructor(signer, btcRelay, swapContractAddress) {
        this.claimWithSecretTimeout = 45;
        this.claimWithTxDataTimeout = 120;
        this.refundTimeout = 45;
        this.claimGracePeriod = 10 * 60;
        this.refundGracePeriod = 10 * 60;
        this.authGracePeriod = 5 * 60;
        this.signer = signer;
        this.btcRelay = btcRelay;
        this.contract = new ethers_1.Contract(swapContractAddress, swapContract_1.swapContract.abi, signer);
        this.contractInterface = new utils_1.Interface(swapContract_1.swapContract.abi);
    }
    getHashForOnchain(outputScript, amount, nonce) {
        const amountBuffer = buffer_1.Buffer.from(amount.toString(16).padStart(16, "0"), "hex").reverse();
        const txoHash = utils.solidityKeccak256(["bytes"], [
            "0x" + buffer_1.Buffer.concat([
                amountBuffer,
                outputScript
            ]).toString("hex")
        ]);
        const nonceHexString = nonce.toString(16).padStart(16, "0");
        const hash = utils.solidityKeccak256(["bytes"], [
            "0x" + nonceHexString + txoHash.substring(2)
        ]);
        return buffer_1.Buffer.from(hash.substring(2), "hex");
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.address = yield this.signer.getAddress();
        });
    }
    areWeClaimer(swapData) {
        return swapData.claimer === this.address;
    }
    areWeOfferer(swapData) {
        return swapData.offerer === this.address;
    }
    getBalance(token, inContract) {
        return __awaiter(this, void 0, void 0, function* () {
            if (inContract) {
                const balance = yield this.contract.balanceOf(this.address, token);
                return new BN(balance.toString());
            }
            else {
                let balance;
                if (token === ZERO_ADDRESS) {
                    balance = yield this.signer.provider.getBalance(this.address);
                }
                else {
                    const contract = new ethers_1.Contract(token, erc20Abi_1.erc20Abi, this.signer.provider);
                    balance = yield contract.balanceOf(this.address);
                }
                return new BN(balance.toString());
            }
        });
    }
    getCommitStatus(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const commitedHash = yield this.contract.getCommitment(data.paymentHash);
            const commitNum = ethers_1.BigNumber.from(commitedHash);
            if (commitNum.eq(ethers_1.BigNumber.from(0x100))) {
                //Success
                return crosslightning_base_1.SwapCommitStatus.PAID;
            }
            if (commitNum.lt(ethers_1.BigNumber.from(0x100))) {
                //Success
                if (this.isExpired(data)) {
                    return crosslightning_base_1.SwapCommitStatus.EXPIRED;
                }
                return crosslightning_base_1.SwapCommitStatus.NOT_COMMITED;
            }
            if (commitedHash === data.getCommitHash()) {
                if (this.areWeOfferer(data)) {
                    if (this.isExpired(data)) {
                        return crosslightning_base_1.SwapCommitStatus.REFUNDABLE;
                    }
                }
                return crosslightning_base_1.SwapCommitStatus.COMMITED;
            }
            else {
                if (this.areWeOfferer(data)) {
                    if (this.isExpired(data)) {
                        return crosslightning_base_1.SwapCommitStatus.EXPIRED;
                    }
                }
                return crosslightning_base_1.SwapCommitStatus.NOT_COMMITED;
            }
        });
    }
    getPaymentHashStatus(paymentHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const commitedHash = yield this.contract.getCommitment("0x" + paymentHash);
            const commitNum = ethers_1.BigNumber.from(commitedHash);
            if (commitNum.eq(ethers_1.BigNumber.from(0x100))) {
                return crosslightning_base_1.SwapCommitStatus.PAID;
            }
            else if (commitNum.lt(ethers_1.BigNumber.from(0x100))) {
                return crosslightning_base_1.SwapCommitStatus.NOT_COMMITED;
            }
            else {
                return crosslightning_base_1.SwapCommitStatus.COMMITED;
            }
        });
    }
    getMessage(swapData, prefix, timeout) {
        const encoded = utils.solidityPack([
            "bytes",
            "bytes32",
            "uint64"
        ], [
            "0x" + buffer_1.Buffer.from(prefix).toString("hex"),
            swapData.getCommitHash(),
            ethers_1.BigNumber.from(timeout)
        ]);
        const messageBuffer = utils.solidityKeccak256(["bytes"], [encoded]);
        return buffer_1.Buffer.from(messageBuffer.substring(2), "hex");
    }
    getClaimInitMessage(swapData, nonce, prefix, timeout) {
        return this.getMessage(swapData, prefix, timeout);
    }
    getClaimInitSignature(swapData, nonce, authorizationTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const authPrefix = "claim_initialize";
            const authTimeout = Math.floor(Date.now() / 1000) + authorizationTimeout;
            const messageBuffer = this.getClaimInitMessage(swapData, swapData.getIndex(), authPrefix, authTimeout.toString());
            const signature = yield this.signer.signMessage(messageBuffer);
            return {
                nonce: swapData.getIndex(),
                prefix: authPrefix,
                timeout: authTimeout.toString(10),
                signature: signature
            };
        });
    }
    isValidClaimInitAuthorization(data, timeout, prefix, signature, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            if (prefix !== "claim_initialize") {
                throw new crosslightning_base_1.SignatureVerificationError("Invalid prefix");
            }
            const expiryTimestamp = new BN(timeout);
            const currentTimestamp = new BN(Math.floor(Date.now() / 1000));
            const isExpired = expiryTimestamp.sub(currentTimestamp).lt(new BN(this.authGracePeriod));
            if (isExpired) {
                throw new crosslightning_base_1.SignatureVerificationError("Authorization expired!");
            }
            //Check correctness of nonce
            const commitment = yield this.contract.getCommitment(data.paymentHash);
            const commitNum = ethers_1.BigNumber.from(commitment);
            if (!commitNum.eq(ethers_1.BigNumber.from(data.getIndex()))) {
                throw new crosslightning_base_1.SignatureVerificationError("Invalid nonce!");
            }
            const messageBuffer = this.getClaimInitMessage(data, nonce, prefix, timeout);
            const recoveredAddress = utils.verifyMessage(messageBuffer, signature);
            const invalidSignature = recoveredAddress.toLowerCase() !== data.claimer.toLowerCase();
            if (invalidSignature) {
                throw new crosslightning_base_1.SignatureVerificationError("Invalid signature!");
            }
            return messageBuffer;
        });
    }
    getInitMessage(swapData, nonce, prefix, timeout) {
        return this.getMessage(swapData, prefix, timeout);
    }
    getInitSignature(swapData, nonce, authorizationTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const authPrefix = "initialize";
            const authTimeout = Math.floor(Date.now() / 1000) + authorizationTimeout;
            const messageBuffer = this.getInitMessage(swapData, swapData.getIndex(), authPrefix, authTimeout.toString(10));
            const signature = yield this.signer.signMessage(messageBuffer);
            return {
                nonce: swapData.getIndex(),
                prefix: authPrefix,
                timeout: authTimeout.toString(10),
                signature: signature
            };
        });
    }
    isValidInitAuthorization(data, timeout, prefix, signature, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            if (prefix !== "initialize") {
                throw new crosslightning_base_1.SignatureVerificationError("Invalid prefix");
            }
            const expiryTimestamp = new BN(timeout);
            const currentTimestamp = new BN(Math.floor(Date.now() / 1000));
            const isExpired = expiryTimestamp.sub(currentTimestamp).lt(new BN(this.authGracePeriod));
            if (isExpired) {
                throw new crosslightning_base_1.SignatureVerificationError("Authorization expired!");
            }
            const swapWillExpireTooSoon = data.getExpiry().sub(currentTimestamp).lt(new BN(this.authGracePeriod).add(new BN(this.claimGracePeriod)));
            if (swapWillExpireTooSoon) {
                throw new crosslightning_base_1.SignatureVerificationError("Swap will expire too soon!");
            }
            //Check correctness of nonce
            const commitment = yield this.contract.getCommitment(data.paymentHash);
            const commitNum = ethers_1.BigNumber.from(commitment);
            if (!commitNum.eq(ethers_1.BigNumber.from(data.getIndex()))) {
                throw new crosslightning_base_1.SignatureVerificationError("Invalid nonce!");
            }
            const messageBuffer = this.getInitMessage(data, nonce, prefix, timeout);
            const recoveredAddress = utils.verifyMessage(messageBuffer, signature);
            const invalidSignature = recoveredAddress.toLowerCase() !== data.offerer.toLowerCase();
            if (invalidSignature) {
                throw new crosslightning_base_1.SignatureVerificationError("Invalid signature!");
            }
            return messageBuffer;
        });
    }
    getRefundMessage(swapData, prefix, timeout) {
        return this.getMessage(swapData, prefix, timeout);
    }
    getRefundSignature(swapData, authorizationTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const authPrefix = "refund";
            const authTimeout = Math.floor(Date.now() / 1000) + authorizationTimeout;
            const messageBuffer = this.getRefundMessage(swapData, authPrefix, authTimeout.toString(10));
            const signature = yield this.signer.signMessage(messageBuffer);
            return {
                prefix: authPrefix,
                timeout: authTimeout.toString(10),
                signature: signature
            };
        });
    }
    isValidRefundAuthorization(swapData, timeout, prefix, signature) {
        if (prefix !== "refund") {
            throw new crosslightning_base_1.SignatureVerificationError("Invalid prefix");
        }
        const expiryTimestamp = new BN(timeout);
        const currentTimestamp = new BN(Math.floor(Date.now() / 1000));
        const isExpired = expiryTimestamp.sub(currentTimestamp).lt(new BN(this.authGracePeriod));
        if (isExpired) {
            throw new crosslightning_base_1.SignatureVerificationError("Authorization expired!");
        }
        const messageBuffer = this.getRefundMessage(swapData, prefix, timeout);
        const recoveredAddress = utils.verifyMessage(messageBuffer, signature);
        const invalidSignature = recoveredAddress.toLowerCase() !== swapData.claimer.toLowerCase();
        if (invalidSignature) {
            throw new crosslightning_base_1.SignatureVerificationError("Invalid signature!");
        }
        return Promise.resolve(messageBuffer);
    }
    getDataSignature(data) {
        const buff = (0, crypto_1.createHash)("sha256").update(data).digest();
        return this.signer.signMessage(buff);
    }
    isValidDataSignature(data, signature, publicKey) {
        const hash = (0, crypto_1.createHash)("sha256").update(data).digest();
        const recoveredAddress = utils.verifyMessage(hash, signature);
        return Promise.resolve(recoveredAddress.toLowerCase() === publicKey.toLowerCase());
    }
    isClaimable(data) {
        if (!this.areWeClaimer(data)) {
            return Promise.resolve(false);
        }
        if (this.isExpired(data)) {
            return Promise.resolve(false);
        }
        return this.isCommited(data);
    }
    isCommited(swapData) {
        return __awaiter(this, void 0, void 0, function* () {
            const commitment = yield this.contract.getCommitment(swapData.paymentHash);
            return commitment === swapData.getCommitHash();
        });
    }
    isExpired(data) {
        let currentTimestamp = new BN(0);
        if (this.areWeOfferer(data)) {
            currentTimestamp = new BN(Math.floor(Date.now() / 1000) - this.refundGracePeriod);
        }
        if (this.areWeClaimer(data)) {
            currentTimestamp = new BN(Math.floor(Date.now() / 1000) + this.claimGracePeriod);
        }
        return data.getExpiry().lt(currentTimestamp);
    }
    isRequestRefundable(data) {
        if (!this.areWeOfferer(data)) {
            return Promise.resolve(false);
        }
        const currentTimestamp = new BN(Math.floor(Date.now() / 1000) - this.refundGracePeriod);
        const isExpired = data.getExpiry().lt(currentTimestamp);
        if (!isExpired)
            return Promise.resolve(false);
        return this.isCommited(data);
    }
    //TODO: Should not be used unless necessary, might take a long time time to retrieve the data
    getCommitedData(paymentHashHex) {
        return __awaiter(this, void 0, void 0, function* () {
            const commitment = yield this.contract.getCommitment("0x" + paymentHashHex);
            const commitNum = ethers_1.BigNumber.from(commitment);
            if (commitNum.lte(ethers_1.BigNumber.from(0x100))) {
                return null;
            }
            const topicFilter = [
                utils.id("Initialize(address,address,bytes32,(address,address,address,uint256,bytes32,uint256),bytes32)"),
                null,
                null,
                "0x" + paymentHashHex
            ];
            console.log("Topic filter: ", topicFilter);
            let currentBlock = (yield this.signer.provider.getBlockNumber()) - 1;
            let swapData = null;
            while (swapData == null) {
                const params = {
                    address: this.contract.address,
                    topics: topicFilter,
                    fromBlock: currentBlock - LOG_FETCH_LIMIT,
                    toBlock: currentBlock
                };
                console.log("getLogs params: ", params);
                const logs = yield this.signer.provider.getLogs(params);
                for (let log of logs) {
                    const event = this.contractInterface.parseLog(log);
                    const data = event.args.data;
                    data.txoHash = event.args.txoHash;
                    const _swapData = new EVMSwapData_1.EVMSwapData(data);
                    if (_swapData.getCommitHash() === commitment)
                        swapData = _swapData;
                }
                currentBlock -= LOG_FETCH_LIMIT;
                if (swapData == null) {
                    yield new Promise(resolve => {
                        setTimeout(resolve, 500);
                    });
                }
            }
            return swapData;
        });
    }
    static typeToKind(type) {
        switch (type) {
            case crosslightning_base_1.ChainSwapType.HTLC:
                return 0;
            case crosslightning_base_1.ChainSwapType.CHAIN:
                return 1;
            case crosslightning_base_1.ChainSwapType.CHAIN_NONCED:
                return 2;
        }
        return null;
    }
    createSwapData(type, offerer, claimer, token, amount, paymentHash, expiry, escrowNonce, confirmations, payIn, payOut) {
        return __awaiter(this, void 0, void 0, function* () {
            const commitment = yield this.contract.getCommitment("0x" + paymentHash);
            const commitNum = ethers_1.BigNumber.from(commitment);
            if (commitNum.gte(ethers_1.BigNumber.from(0x100))) {
                throw new Error("Already committed or already paid");
            }
            return new EVMSwapData_1.EVMSwapData(offerer, claimer, token, amount == null ? null : ethers_1.BigNumber.from(amount.toString(10)), paymentHash == null ? null : "0x" + paymentHash, expiry == null ? null : ethers_1.BigNumber.from(expiry.toString(10)), escrowNonce == null ? null : ethers_1.BigNumber.from(escrowNonce.toString(10)), confirmations, EVMSwapProgram.typeToKind(type), payIn, payOut, commitNum.toNumber(), null);
        });
    }
    //TODO: Implement abortSignal
    sendAndConfirm(txs, waitForConfirmation, abortSignal, parallel) {
        return __awaiter(this, void 0, void 0, function* () {
            const txIds = [];
            let resp = null;
            if (!parallel) {
                for (let tx of txs) {
                    if (resp != null) {
                        const receipt = yield this.signer.provider.waitForTransaction(resp.hash);
                        if (!receipt.status) {
                            throw new Error("Transaction reverted, txId: " + receipt.transactionHash);
                        }
                    }
                    resp = yield this.signer.sendTransaction(tx);
                    txIds.push(resp.hash);
                }
            }
            else {
                for (let tx of txs) {
                    resp = yield this.signer.sendTransaction(tx);
                    txIds.push(resp.hash);
                }
            }
            if (waitForConfirmation) {
                const receipt = yield this.signer.provider.waitForTransaction(resp.hash);
                if (!receipt.status) {
                    throw new Error("Transaction reverted, txId: " + receipt.transactionHash);
                }
            }
            return txIds;
        });
    }
    claimWithSecret(swapData, secret, checkExpiry, initAta, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.txsClaimWithSecret(swapData, secret, checkExpiry, initAta);
            const [signature] = yield this.sendAndConfirm(result, waitForConfirmation, abortSignal);
            console.log("[To BTCLN: Solana.PaymentResult] Transaction sent: ", signature);
            return signature;
        });
    }
    txsClaimWithSecret(swapData, secret, checkExpiry, initAta) {
        return __awaiter(this, void 0, void 0, function* () {
            if (checkExpiry) {
                const expiryTimestamp = swapData.getExpiry();
                const currentTimestamp = Math.floor(Date.now() / 1000);
                console.log("[EVM.PaymentRequest] Expiry time: ", expiryTimestamp.toString());
                if (expiryTimestamp.sub(new BN(currentTimestamp)).lt(new BN(this.claimGracePeriod))) {
                    console.error("[EVM.PaymentRequest] Not enough time to reliably pay the invoice");
                    throw new crosslightning_base_1.SwapDataVerificationError("Not enough time to reliably pay the invoice");
                }
            }
            const tx = yield this.contract.populateTransaction.claimer_claim(swapData, "0x" + secret);
            tx.gasLimit = GAS_CLAIM_WITH_SECRET;
            return [tx];
        });
    }
    claimWithTxData(swapData, blockheight, tx, vout, commitedHeader, synchronizer, initAta, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            const txs = yield this.txsClaimWithTxData(swapData, blockheight, tx, vout, commitedHeader, synchronizer, initAta);
            if (txs == null)
                throw new Error("Cannot claim due to BTC Relay not being synchronized");
            const [signature] = yield this.sendAndConfirm(txs, waitForConfirmation, abortSignal, true);
            return signature;
        });
    }
    //TODO: Check if tx really claims paymentHash
    txsClaimWithTxData(swapData, blockheight, tx, vout, commitedHeader, synchronizer, initAta) {
        return __awaiter(this, void 0, void 0, function* () {
            const merkleProof = yield this.btcRelay.bitcoinRpc.getMerkleProof(tx.txid, tx.blockhash);
            const txs = [];
            if (synchronizer == null) {
                if (commitedHeader == null)
                    try {
                        const result = yield this.btcRelay.retrieveLogAndBlockheight({ blockhash: tx.blockhash, height: merkleProof.blockheight }, blockheight + swapData.getConfirmations() - 1);
                        if (result == null)
                            return null;
                        commitedHeader = result.header;
                    }
                    catch (e) {
                        console.error(e);
                    }
                console.log("[Solana.Claim] Commited header retrieved: ", commitedHeader);
                if (commitedHeader == null)
                    return null;
            }
            else {
                if (commitedHeader == null) {
                    const requiredBlockheight = merkleProof.blockheight + swapData.getConfirmations() - 1;
                    const result = yield this.btcRelay.retrieveLogAndBlockheight({ blockhash: tx.blockhash, height: merkleProof.blockheight });
                    commitedHeader = result.header;
                    if (result.height < requiredBlockheight) {
                        //Need to synchronize
                        //TODO: We don't have to synchronize to tip, only to our required blockheight
                        const resp = yield synchronizer.syncToLatestTxs();
                        console.log("BTC Relay not synchronized to required blockheight, synchronizing ourselves in " + resp.txs.length + " txs");
                        console.log("BTC Relay computed header map: ", resp.computedHeaderMap);
                        if (commitedHeader == null) {
                            //Retrieve computed header
                            commitedHeader = resp.computedHeaderMap[merkleProof.blockheight];
                        }
                        resp.txs.forEach(tx => txs.push(tx));
                    }
                }
            }
            console.log("[To BTC: Solana.Claim] Merkle proof computed: ", merkleProof);
            console.log("[To BTC: Solana.Claim] Writing transaction data: ", tx.hex);
            const evmTx = yield this.contract.populateTransaction.claimer_claimWithTxData(swapData, ethers_1.BigNumber.from(vout), "0x" + tx.hex, {
                blockheight: ethers_1.BigNumber.from(merkleProof.blockheight),
                txPos: ethers_1.BigNumber.from(merkleProof.pos),
                merkleProof: "0x" + buffer_1.Buffer.concat(merkleProof.merkle).toString("hex"),
                committedHeader: commitedHeader
            });
            evmTx.gasLimit = ethers_1.BigNumber.from(GAS_CLAIM_WITH_TX_DATA_BASE + (GAS_CLAIM_WITH_TX_DATA_PER_TX_BYTE * tx.hex.length / 2));
            txs.push(evmTx);
            return txs;
        });
    }
    refund(swapData, check, initAta, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.txsRefund(swapData);
            const [signature] = yield this.sendAndConfirm(result, waitForConfirmation, abortSignal);
            return signature;
        });
    }
    txsRefund(swapData, check, initAta) {
        return __awaiter(this, void 0, void 0, function* () {
            if (check) {
                if (!(yield this.isRequestRefundable(swapData))) {
                    throw new crosslightning_base_1.SwapDataVerificationError("Not refundable yet!");
                }
            }
            const tx = yield this.contract.populateTransaction.offerer_refund(swapData);
            tx.gasLimit = ethers_1.BigNumber.from(GAS_REFUND);
            return [tx];
        });
    }
    refundWithAuthorization(swapData, timeout, prefix, signature, check, initAta, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.txsRefundWithAuthorization(swapData, timeout, prefix, signature, check, initAta);
            const [txSignature] = yield this.sendAndConfirm(result, waitForConfirmation, abortSignal);
            return txSignature;
        });
    }
    txsRefundWithAuthorization(swapData, timeout, prefix, signature, check, initAta) {
        return __awaiter(this, void 0, void 0, function* () {
            if (check) {
                if (!(yield this.isCommited(swapData))) {
                    throw new crosslightning_base_1.SwapDataVerificationError("Not correctly committed");
                }
            }
            const sig = utils.splitSignature(signature);
            const tx = yield this.contract.populateTransaction.offerer_refundWithAuth(swapData, EVMSwapProgram.getSignatureStruct(signature, timeout));
            tx.gasLimit = ethers_1.BigNumber.from(GAS_REFUND_WITH_AUTH);
            return [tx];
        });
    }
    initPayIn(swapData, timeout, prefix, signature, nonce, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.txsInitPayIn(swapData, timeout, prefix, signature, nonce);
            const [txSignature] = yield this.sendAndConfirm(result, waitForConfirmation, abortSignal, true);
            return txSignature;
        });
    }
    txsInitPayIn(swapData, timeout, prefix, signature, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            const payStatus = yield this.getPaymentHashStatus(swapData.getHash());
            if (payStatus !== crosslightning_base_1.SwapCommitStatus.NOT_COMMITED) {
                throw new crosslightning_base_1.SwapDataVerificationError("Invoice already being paid for or paid");
            }
            const txs = [];
            if (swapData.token !== ZERO_ADDRESS) {
                const tokenContract = new ethers_1.Contract(swapData.token, erc20Abi_1.erc20Abi, this.signer);
                const allowance = yield tokenContract.allowance(swapData.offerer, this.contract.address);
                if (allowance.lt(swapData.amount)) {
                    //Increase allowance
                    const allowanceTx = yield tokenContract.populateTransaction.approve(this.contract.address, MAX_ALLOWANCE);
                    allowanceTx.gasLimit = ethers_1.BigNumber.from(80000);
                    txs.push(allowanceTx);
                }
            }
            const tx = yield this.contract.populateTransaction.offerer_claimInit(swapData, EVMSwapProgram.getSignatureStruct(signature, timeout), "0x0000000000000000000000000000000000000000000000000000000000000000");
            if (swapData.token === ZERO_ADDRESS) {
                tx.value = swapData.amount;
            }
            tx.gasLimit = ethers_1.BigNumber.from(GAS_CLAIM_INIT);
            txs.push(tx);
            return txs;
        });
    }
    init(swapData, timeout, prefix, signature, nonce, txoHash, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.txsInit(swapData, timeout, prefix, signature, nonce, txoHash);
            const [txSignature] = yield this.sendAndConfirm(result, waitForConfirmation, abortSignal);
            return txSignature;
        });
    }
    txsInit(swapData, timeout, prefix, signature, nonce, txoHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const requiredDeposit = yield this.contract.SECURITY_DEPOSIT();
            const tx = yield this.contract.populateTransaction.offerer_init(swapData, EVMSwapProgram.getSignatureStruct(signature, timeout), txoHash != null ?
                "0x" + txoHash.toString("hex") :
                "0x0000000000000000000000000000000000000000000000000000000000000000");
            tx.value = requiredDeposit;
            tx.gasLimit = ethers_1.BigNumber.from(GAS_INIT);
            return [tx];
        });
    }
    initAndClaimWithSecret(swapData, timeout, prefix, signature, nonce, secret, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            const [txCommit] = yield this.txsInit(swapData, timeout, prefix, signature, nonce);
            const [txClaim] = yield this.txsClaimWithSecret(swapData, secret, true, true);
            return yield this.sendAndConfirm([txCommit, txClaim], waitForConfirmation, abortSignal, false);
        });
    }
    getAddress() {
        return this.address;
    }
    isValidAddress(address) {
        try {
            return utils.isAddress(address);
        }
        catch (e) {
            return false;
        }
    }
    getIntermediaryReputation(address, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const reputationResponse = yield this.contract.getReputation(address, token);
            const response = [];
            for (let i = 0; i < 3; i++) {
                const success = reputationResponse[i].success;
                const coopClose = reputationResponse[i].coopClose;
                const failed = reputationResponse[i].failed;
                response[i] = {
                    successVolume: new BN(success.and(ethers_1.BigNumber.from("0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).toString()),
                    successCount: new BN(success.shr(224).toString()),
                    failVolume: new BN(failed.and(ethers_1.BigNumber.from("0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).toString()),
                    failCount: new BN(failed.shr(224).toString()),
                    coopCloseVolume: new BN(coopClose.and(ethers_1.BigNumber.from("0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).toString()),
                    coopCloseCount: new BN(coopClose.shr(224).toString())
                };
            }
            return response;
        });
    }
    getIntermediaryBalance(address, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield this.contract.balanceOf(address, token);
            return new BN(balance.toString());
        });
    }
    toTokenAddress(address) {
        return address;
    }
    getClaimFee() {
        return __awaiter(this, void 0, void 0, function* () {
            const securityDeposit = yield this.contract.SECURITY_DEPOSIT();
            const gasPrice = yield this.signer.provider.getGasPrice();
            const gasLimit = ethers_1.BigNumber.from(GAS_CLAIM_WITH_SECRET);
            const gasFee = gasPrice.mul(gasLimit);
            return new BN(securityDeposit.sub(gasFee).toString());
        });
    }
    /**
     * Get the estimated solana fee of the commit transaction
     */
    getCommitFee() {
        return __awaiter(this, void 0, void 0, function* () {
            const securityDeposit = yield this.contract.SECURITY_DEPOSIT();
            const gasPrice = yield this.signer.provider.getGasPrice();
            const gasLimit = ethers_1.BigNumber.from(GAS_CLAIM_INIT);
            const gasFee = gasPrice.mul(gasLimit);
            return new BN(securityDeposit.add(gasFee));
        });
    }
    /**
     * Get the estimated solana transaction fee of the refund transaction
     */
    getRefundFee() {
        return __awaiter(this, void 0, void 0, function* () {
            const securityDeposit = yield this.contract.SECURITY_DEPOSIT();
            const gasPrice = yield this.signer.provider.getGasPrice();
            const gasLimit = ethers_1.BigNumber.from(GAS_REFUND_WITH_AUTH);
            const gasFee = gasPrice.mul(gasLimit);
            return new BN(securityDeposit.sub(gasFee).toString());
        });
    }
    setUsAsClaimer(swapData) {
        swapData.claimer = this.address;
        swapData.setPayIn(false);
        swapData.setPayOut(true);
    }
    setUsAsOfferer(swapData) {
        swapData.offerer = this.address;
        swapData.setPayIn(true);
    }
    getAllowance(swapData) {
        if (ZERO_ADDRESS === swapData.token)
            return Promise.resolve(MAX_ALLOWANCE);
        const tokenContract = new ethers_1.Contract(swapData.token, erc20Abi_1.erc20Abi, this.signer);
        return tokenContract.allowance(swapData.offerer, this.contract.address);
    }
    approveSpend(swapData, waitForConfirmation, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            if (ZERO_ADDRESS === swapData.token)
                return Promise.resolve("0x0000000000000000000000000000000000000000000000000000000000000000");
            const tokenContract = new ethers_1.Contract(swapData.token, erc20Abi_1.erc20Abi, this.signer);
            const allowanceTx = yield tokenContract.populateTransaction.approve(this.contract.address, MAX_ALLOWANCE);
            allowanceTx.gasLimit = ethers_1.BigNumber.from(80000);
            const [txId] = yield this.sendAndConfirm([allowanceTx], waitForConfirmation, abortSignal, false);
            return txId;
        });
    }
}
exports.EVMSwapProgram = EVMSwapProgram;
