"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMSwapData = void 0;
const BN = require("bn.js");
const crosslightning_base_1 = require("crosslightning-base");
const ethers_1 = require("ethers");
class EVMSwapData extends crosslightning_base_1.SwapData {
    constructor(offererOrData, claimer, token, amount, paymentHash, expiry, nonce, confirmations, kind, payIn, payOut, index, txoHash) {
        super();
        if (claimer != null || token != null || amount != null || paymentHash != null || expiry != null || txoHash != null ||
            nonce != null || confirmations != null || payOut != null || kind != null || payIn != null || index != null) {
            expiry = expiry || ethers_1.BigNumber.from(0);
            nonce = nonce || ethers_1.BigNumber.from(0);
            confirmations = confirmations || 0;
            this.offerer = offererOrData;
            this.claimer = claimer;
            this.token = token;
            this.amount = amount;
            this.paymentHash = paymentHash;
            this.data = expiry.and(ethers_1.BigNumber.from("0xFFFFFFFFFFFFFFFF"))
                .or(nonce.and(ethers_1.BigNumber.from("0xFFFFFFFFFFFFFFFF")).shl(64))
                .or(ethers_1.BigNumber.from(confirmations).and(ethers_1.BigNumber.from(0xFFFF)).shl(128))
                .or(ethers_1.BigNumber.from(kind).and(ethers_1.BigNumber.from(0xFF)).shl(144))
                .or(ethers_1.BigNumber.from(payIn ? 1 : 0).and(ethers_1.BigNumber.from(0xFF)).shl(152))
                .or(ethers_1.BigNumber.from(payOut ? 1 : 0).and(ethers_1.BigNumber.from(0xFF)).shl(160))
                .or(ethers_1.BigNumber.from(index).and(ethers_1.BigNumber.from(0xFF)).shl(168));
            this.txoHash = txoHash;
        }
        else {
            this.offerer = offererOrData.offerer;
            this.claimer = offererOrData.claimer;
            this.token = offererOrData.token;
            this.amount = offererOrData.amount == null ? null : ethers_1.BigNumber.from(offererOrData.amount);
            this.paymentHash = offererOrData.paymentHash;
            this.data = offererOrData.data == null ? null : ethers_1.BigNumber.from(offererOrData.data);
            this.txoHash = offererOrData.txoHash;
        }
    }
    getOfferer() {
        return this.offerer;
    }
    setOfferer(newOfferer) {
        this.offerer = newOfferer;
    }
    getClaimer() {
        return this.claimer;
    }
    setClaimer(newClaimer) {
        this.claimer = newClaimer;
    }
    serialize() {
        return {
            type: "evm",
            offerer: this.offerer,
            claimer: this.claimer,
            token: this.token,
            amount: this.amount == null ? null : this.amount.toHexString(),
            paymentHash: this.paymentHash,
            data: this.data == null ? null : this.data.toHexString(),
            txoHash: this.txoHash
        };
    }
    getAmount() {
        if (this.amount == null)
            return null;
        return new BN(this.amount.toString());
    }
    getToken() {
        return this.token;
    }
    isToken(token) {
        return this.token.toLowerCase() === token.toLowerCase();
    }
    getKind() {
        return this.data.shr(144).and(ethers_1.BigNumber.from(0xFF)).toNumber();
    }
    getType() {
        switch (this.getKind()) {
            case 0:
                return crosslightning_base_1.ChainSwapType.HTLC;
            case 1:
                return crosslightning_base_1.ChainSwapType.CHAIN;
            case 2:
                return crosslightning_base_1.ChainSwapType.CHAIN_NONCED;
        }
        return null;
    }
    getExpiry() {
        const expiryBigNum = this.data.and(ethers_1.BigNumber.from("0xFFFFFFFFFFFFFFFF"));
        return new BN(expiryBigNum.toString());
    }
    getConfirmations() {
        return this.data.shr(128).and(ethers_1.BigNumber.from(0xFFFF)).toNumber();
    }
    getEscrowNonce() {
        return new BN(this.data.shr(64).and(ethers_1.BigNumber.from("0xFFFFFFFFFFFFFFFF")).toString());
    }
    isPayIn() {
        return this.data.shr(152).and(ethers_1.BigNumber.from("0xFF")).gt(ethers_1.BigNumber.from(0));
    }
    setPayIn(payIn) {
        this.data = this.data.and(ethers_1.BigNumber.from("0x00000000000000000000FFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"))
            .or(ethers_1.BigNumber.from(payIn ? 1 : 0).shl(152));
    }
    isPayOut() {
        return this.data.shr(160).and(ethers_1.BigNumber.from("0xFF")).gt(ethers_1.BigNumber.from(0));
    }
    setPayOut(payOut) {
        this.data = this.data.and(ethers_1.BigNumber.from("0x00000000000000000000FF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"))
            .or(ethers_1.BigNumber.from(payOut ? 1 : 0).shl(160));
    }
    getIndex() {
        return this.data.shr(168).and(ethers_1.BigNumber.from("0xFF")).toNumber();
    }
    getHash() {
        return this.paymentHash == null ? null : this.paymentHash.substring(2);
    }
    getTxoHash() {
        return this.txoHash == null ? null : this.txoHash.substring(2);
    }
    getBytes() {
        return ethers_1.utils.defaultAbiCoder.encode([
            "tuple(address offerer,address claimer,address token,uint256 amount,bytes32 paymentHash,uint256 data)"
        ], [
            {
                offerer: this.offerer,
                claimer: this.claimer,
                token: this.token,
                amount: this.amount,
                paymentHash: this.paymentHash,
                data: this.data
            }
        ]);
    }
    getCommitHash() {
        const encoded = this.getBytes();
        return ethers_1.utils.solidityKeccak256(["bytes"], [encoded]);
    }
}
exports.EVMSwapData = EVMSwapData;
crosslightning_base_1.SwapData.deserializers["evm"] = EVMSwapData;
