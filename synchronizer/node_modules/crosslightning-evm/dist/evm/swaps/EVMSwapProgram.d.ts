/// <reference types="node" />
import * as BN from "bn.js";
import { ISwapNonce, SwapContract, ChainSwapType, IntermediaryReputationType, SwapCommitStatus, RelaySynchronizer } from "crosslightning-base";
import { BigNumber, Contract, Signer, UnsignedTransaction } from "ethers";
import { EVMBtcRelay } from "../btcrelay/EVMBtcRelay";
import { Interface } from "ethers/lib/utils";
import { EVMSwapData } from "./EVMSwapData";
import { Buffer } from "buffer";
import { EVMBtcStoredHeader } from "../btcrelay/headers/EVMBtcStoredHeader";
export declare class EVMSwapProgram implements SwapContract<EVMSwapData, UnsignedTransaction> {
    static getSignatureStruct(signature: string, timeout: string): {
        r: string;
        s: string;
        vAndTimeout: BigNumber;
    };
    readonly claimWithSecretTimeout: number;
    readonly claimWithTxDataTimeout: number;
    readonly refundTimeout: number;
    readonly claimGracePeriod: number;
    readonly refundGracePeriod: number;
    readonly authGracePeriod: number;
    private readonly signer;
    private address;
    readonly contract: Contract;
    readonly contractInterface: Interface;
    readonly btcRelay: EVMBtcRelay<any>;
    constructor(signer: Signer, btcRelay: EVMBtcRelay<any>, swapContractAddress: string);
    getHashForOnchain(outputScript: Buffer, amount: BN, nonce: BN): Buffer;
    start(): Promise<void>;
    areWeClaimer(swapData: EVMSwapData): boolean;
    areWeOfferer(swapData: EVMSwapData): boolean;
    getBalance(token: string, inContract: boolean): Promise<BN>;
    getCommitStatus(data: EVMSwapData): Promise<SwapCommitStatus>;
    getPaymentHashStatus(paymentHash: string): Promise<SwapCommitStatus>;
    getMessage(swapData: EVMSwapData, prefix: string, timeout: string): Buffer;
    getClaimInitMessage(swapData: EVMSwapData, nonce: number, prefix: string, timeout: string): Buffer;
    getClaimInitSignature(swapData: EVMSwapData, nonce: ISwapNonce, authorizationTimeout: number): Promise<{
        nonce: number;
        prefix: string;
        timeout: string;
        signature: string;
    }>;
    isValidClaimInitAuthorization(data: EVMSwapData, timeout: string, prefix: string, signature: string, nonce: number): Promise<Buffer>;
    getInitMessage(swapData: EVMSwapData, nonce: number, prefix: string, timeout: string): Buffer;
    getInitSignature(swapData: EVMSwapData, nonce: ISwapNonce, authorizationTimeout: number): Promise<{
        nonce: number;
        prefix: string;
        timeout: string;
        signature: string;
    }>;
    isValidInitAuthorization(data: EVMSwapData, timeout: string, prefix: string, signature: string, nonce: number): Promise<Buffer>;
    getRefundMessage(swapData: EVMSwapData, prefix: string, timeout: string): Buffer;
    getRefundSignature(swapData: EVMSwapData, authorizationTimeout: number): Promise<{
        prefix: string;
        timeout: string;
        signature: string;
    }>;
    isValidRefundAuthorization(swapData: EVMSwapData, timeout: string, prefix: string, signature: string): Promise<Buffer>;
    getDataSignature(data: Buffer): Promise<string>;
    isValidDataSignature(data: Buffer, signature: string, publicKey: string): Promise<boolean>;
    isClaimable(data: EVMSwapData): Promise<boolean>;
    isCommited(swapData: EVMSwapData): Promise<boolean>;
    isExpired(data: EVMSwapData): boolean;
    isRequestRefundable(data: EVMSwapData): Promise<boolean>;
    getCommitedData(paymentHashHex: string): Promise<EVMSwapData>;
    static typeToKind(type: ChainSwapType): number;
    createSwapData(type: ChainSwapType, offerer: string, claimer: string, token: string, amount: BN, paymentHash: string, expiry: BN, escrowNonce: BN, confirmations: number, payIn: boolean, payOut: boolean): Promise<EVMSwapData>;
    sendAndConfirm(txs: UnsignedTransaction[], waitForConfirmation?: boolean, abortSignal?: AbortSignal, parallel?: boolean): Promise<string[]>;
    claimWithSecret(swapData: EVMSwapData, secret: string, checkExpiry?: boolean, initAta?: boolean, waitForConfirmation?: any, abortSignal?: AbortSignal): Promise<string>;
    txsClaimWithSecret(swapData: EVMSwapData, secret: string, checkExpiry?: boolean, initAta?: boolean): Promise<UnsignedTransaction[]>;
    claimWithTxData(swapData: EVMSwapData, blockheight: number, tx: {
        blockhash: string;
        confirmations: number;
        txid: string;
        hex: string;
    }, vout: number, commitedHeader?: EVMBtcStoredHeader, synchronizer?: RelaySynchronizer<any, UnsignedTransaction, any>, initAta?: boolean, waitForConfirmation?: boolean, abortSignal?: AbortSignal): Promise<string>;
    txsClaimWithTxData(swapData: EVMSwapData, blockheight: number, tx: {
        blockhash: string;
        confirmations: number;
        txid: string;
        hex: string;
    }, vout: number, commitedHeader?: EVMBtcStoredHeader, synchronizer?: RelaySynchronizer<any, UnsignedTransaction, any>, initAta?: boolean): Promise<UnsignedTransaction[] | null>;
    refund(swapData: EVMSwapData, check?: boolean, initAta?: boolean, waitForConfirmation?: boolean, abortSignal?: AbortSignal): Promise<string>;
    txsRefund(swapData: EVMSwapData, check?: boolean, initAta?: boolean): Promise<UnsignedTransaction[]>;
    refundWithAuthorization(swapData: EVMSwapData, timeout: string, prefix: string, signature: string, check?: boolean, initAta?: boolean, waitForConfirmation?: boolean, abortSignal?: AbortSignal): Promise<string>;
    txsRefundWithAuthorization(swapData: EVMSwapData, timeout: string, prefix: string, signature: string, check?: boolean, initAta?: boolean): Promise<UnsignedTransaction[]>;
    initPayIn(swapData: EVMSwapData, timeout: string, prefix: string, signature: string, nonce: number, waitForConfirmation?: boolean, abortSignal?: AbortSignal): Promise<string>;
    txsInitPayIn(swapData: EVMSwapData, timeout: string, prefix: string, signature: string, nonce: number): Promise<UnsignedTransaction[]>;
    init(swapData: EVMSwapData, timeout: string, prefix: string, signature: string, nonce: number, txoHash?: Buffer, waitForConfirmation?: boolean, abortSignal?: AbortSignal): Promise<string>;
    txsInit(swapData: EVMSwapData, timeout: string, prefix: string, signature: string, nonce: number, txoHash?: Buffer): Promise<UnsignedTransaction[]>;
    initAndClaimWithSecret(swapData: EVMSwapData, timeout: string, prefix: string, signature: string, nonce: number, secret: string, waitForConfirmation?: boolean, abortSignal?: AbortSignal): Promise<string[]>;
    getAddress(): string;
    isValidAddress(address: string): boolean;
    getIntermediaryReputation(address: string, token: string): Promise<IntermediaryReputationType>;
    getIntermediaryBalance(address: string, token: string): Promise<BN>;
    toTokenAddress(address: string): string;
    getClaimFee(): Promise<BN>;
    /**
     * Get the estimated solana fee of the commit transaction
     */
    getCommitFee(): Promise<BN>;
    /**
     * Get the estimated solana transaction fee of the refund transaction
     */
    getRefundFee(): Promise<BN>;
    setUsAsClaimer(swapData: EVMSwapData): void;
    setUsAsOfferer(swapData: EVMSwapData): void;
    getAllowance(swapData: EVMSwapData): Promise<BigNumber>;
    approveSpend(swapData: EVMSwapData, waitForConfirmation?: boolean, abortSignal?: AbortSignal): Promise<string>;
}
