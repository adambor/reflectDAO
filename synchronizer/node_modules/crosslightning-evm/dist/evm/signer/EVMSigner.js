"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMWallet = exports.OverridenStaticJsonRpcProvider = void 0;
const ethers_1 = require("ethers");
const fs = require("fs/promises");
const WAIT_BEFORE_BUMP = 15 * 1000;
const MIN_FEE_INCREASE = ethers_1.BigNumber.from(10 * 1000000000);
class OverridenStaticJsonRpcProvider extends ethers_1.providers.StaticJsonRpcProvider {
    constructor(rpcUrl, chainId) {
        super(rpcUrl, {
            chainId,
            name: "EVM"
        });
        this.waitTxs = {};
    }
    txConfirmed(originalTransactionHash, replacement) {
        if (this.waitTxs[originalTransactionHash] == null)
            return;
        this.waitTxs[originalTransactionHash].resolve(replacement);
        delete this.waitTxs[originalTransactionHash];
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
        const _super = Object.create(null, {
            waitForTransaction: { get: () => super.waitForTransaction }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield this.getTransactionReceipt(transactionHash);
            if (receipt != null)
                return receipt;
            const timestampStart = Date.now();
            const tx = yield new Promise((resolve, reject) => {
                let timeoutObj;
                if (timeout > 0)
                    timeoutObj = setTimeout(() => {
                        if (this.waitTxs[transactionHash] != null)
                            delete this.waitTxs[transactionHash];
                        reject(new Error("Timed out"));
                    }, timeout);
                this.waitTxs[transactionHash] = {
                    resolve: (tx) => {
                        if (timeoutObj != null)
                            clearTimeout(timeoutObj);
                        resolve(tx);
                    }
                };
            });
            const timeElapsed = Date.now() - timestampStart;
            if (confirmations == null || confirmations === 1) {
                return tx;
            }
            else {
                return yield _super.waitForTransaction.call(this, tx.transactionHash, confirmations, timeout - timeElapsed);
            }
        });
    }
}
exports.OverridenStaticJsonRpcProvider = OverridenStaticJsonRpcProvider;
class EVMWallet extends ethers_1.Wallet {
    constructor(privateKey, rpcUrl, chainId, directory) {
        super(privateKey, new OverridenStaticJsonRpcProvider(rpcUrl, chainId));
        this.pendingTxs = {};
        this.txMap = {};
        this.stopped = false;
        this.saveCount = 0;
        this.directory = directory;
        this.chainId = chainId;
        this.boundTransactionListener = this.transactionListener.bind(this);
    }
    transactionListener(transaction) {
        const provider = this.provider;
        const nonce = this.txMap[transaction.transactionHash];
        if (nonce == null)
            return;
        const data = this.pendingTxs[nonce.toString()];
        for (let tx of data.txs) {
            if (this.txMap[tx.hash] != null)
                delete this.txMap[tx.hash];
            this.provider.off(tx.hash, this.boundTransactionListener);
        }
        delete this.pendingTxs[nonce.toString()];
        this.confirmedNonce = nonce;
        provider.txConfirmed(data.txs[0].hash, transaction);
        this.save();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield fs.mkdir(this.directory);
            }
            catch (e) { }
            const txCount = yield this.provider.getTransactionCount(this.address, "latest");
            this.confirmedNonce = txCount - 1;
            this.pendingNonce = txCount - 1;
            const res = yield fs.readFile(this.directory + "/txs.json").catch(e => console.error(e));
            if (res != null) {
                const pendingTxs = JSON.parse(res.toString());
                for (let nonceStr in pendingTxs) {
                    const nonce = parseInt(nonceStr);
                    if (nonce > txCount) {
                        if (this.pendingNonce < nonce) {
                            this.pendingNonce = nonce;
                        }
                        this.pendingTxs[nonceStr] = {
                            txs: pendingTxs[nonceStr].txs.map(tx => {
                                return ethers_1.utils.parseTransaction(tx);
                            }),
                            lastBumped: pendingTxs[nonceStr].lastBumped
                        };
                        for (let tx of this.pendingTxs[nonceStr].txs) {
                            this.txMap[tx.hash] = tx.nonce;
                            this.provider.on(tx.hash, this.boundTransactionListener);
                        }
                    }
                }
            }
            let func;
            func = () => __awaiter(this, void 0, void 0, function* () {
                try {
                    let _gasPrice = null;
                    for (let nonceStr in this.pendingTxs) {
                        const data = this.pendingTxs[nonceStr];
                        if (data.lastBumped < Date.now() - WAIT_BEFORE_BUMP) {
                            const lastTx = data.txs[data.txs.length - 1];
                            if (_gasPrice == null)
                                _gasPrice = yield this.provider.getGasPrice();
                            const feeDifference = _gasPrice.sub(lastTx.gasPrice);
                            const newTx = ethers_1.utils.shallowCopy(lastTx);
                            if (feeDifference.lt(MIN_FEE_INCREASE)) {
                                newTx.gasPrice = lastTx.gasPrice.add(MIN_FEE_INCREASE);
                            }
                            else {
                                newTx.gasPrice = _gasPrice;
                            }
                            delete newTx.r;
                            delete newTx.s;
                            delete newTx.v;
                            delete newTx.hash;
                            delete newTx.from;
                            const signedTx = yield this.signTransaction(newTx);
                            if (this.pendingTxs[nonceStr] == null)
                                continue;
                            const parsed = ethers_1.utils.parseTransaction(signedTx);
                            data.txs.push(parsed);
                            data.lastBumped = Date.now();
                            this.save();
                            this.txMap[parsed.hash] = parsed.nonce;
                            this.provider.on(parsed.hash, this.boundTransactionListener);
                            yield this.provider.sendTransaction(signedTx).catch(e => console.error(e));
                        }
                    }
                }
                catch (e) {
                    console.error(e);
                }
                if (this.stopped)
                    return;
                this.feeBumper = setTimeout(func, 1000);
            });
            func();
        });
    }
    stop() {
        this.stopped = true;
        if (this.feeBumper != null) {
            clearTimeout(this.feeBumper);
            this.feeBumper = null;
        }
        for (let nonceStr in this.pendingTxs) {
            for (let tx of this.pendingTxs[nonceStr].txs) {
                this.provider.removeAllListeners(tx.hash);
            }
        }
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            const pendingTxs = {};
            for (let nonceStr in this.pendingTxs) {
                const txs = this.pendingTxs[nonceStr].txs;
                pendingTxs[nonceStr] = {
                    txs: txs.map(tx => {
                        const signature = {
                            r: tx.r,
                            s: tx.s,
                            v: tx.v
                        };
                        const txCpy = ethers_1.utils.shallowCopy(tx);
                        delete txCpy.r;
                        delete txCpy.s;
                        delete txCpy.v;
                        delete txCpy.hash;
                        delete txCpy.from;
                        return ethers_1.utils.serializeTransaction(txCpy, signature);
                    }),
                    lastBumped: this.pendingTxs[nonceStr].lastBumped
                };
            }
            const requiredSaveCount = ++this.saveCount;
            if (this.priorSavePromise != null) {
                yield this.priorSavePromise;
            }
            if (requiredSaveCount === this.saveCount) {
                this.priorSavePromise = fs.writeFile(this.directory + "/txs.json", JSON.stringify(pendingTxs));
                yield this.priorSavePromise;
            }
        });
    }
    signTransaction(transaction) {
        const _super = Object.create(null, {
            signTransaction: { get: () => super.signTransaction }
        });
        return __awaiter(this, void 0, void 0, function* () {
            transaction.from = this.address;
            transaction.chainId = this.chainId;
            return yield _super.signTransaction.call(this, transaction);
        });
    }
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const gasPrice = yield this.provider.getGasPrice();
            //const gasPrice: BigNumber = BigNumber.from(2*1000000000);
            transaction.gasPrice = gasPrice;
            this.pendingNonce++;
            transaction.nonce = ethers_1.BigNumber.from(this.pendingNonce);
            const tx = {};
            for (let key in transaction) {
                if (transaction[key] instanceof Promise) {
                    tx[key] = yield transaction[key];
                }
                else {
                    tx[key] = transaction[key];
                }
            }
            const signedTx = yield this.signTransaction(tx);
            const parsed = ethers_1.utils.parseTransaction(signedTx);
            this.pendingTxs[transaction.nonce.toString()] = {
                txs: [parsed],
                lastBumped: Date.now()
            };
            this.save();
            this.txMap[parsed.hash] = parsed.nonce;
            this.provider.on(parsed.hash, this.boundTransactionListener);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
}
exports.EVMWallet = EVMWallet;
