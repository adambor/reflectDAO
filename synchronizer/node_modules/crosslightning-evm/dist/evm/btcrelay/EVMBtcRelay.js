"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMBtcRelay = void 0;
const crosslightning_base_1 = require("crosslightning-base");
const btcRelayContract_1 = require("./contract/btcRelayContract");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const EVMBtcStoredHeader_1 = require("./headers/EVMBtcStoredHeader");
const EVMBtcHeader_1 = require("./headers/EVMBtcHeader");
const limit = 2500;
class EVMBtcRelay {
    constructor(provider, bitcoinRpc, btcRelayContractAddress) {
        this.maxHeadersPerTx = 100;
        this.maxForkHeadersPerTx = 50;
        this.provider = provider;
        this.contract = new ethers_1.Contract(btcRelayContractAddress, btcRelayContract_1.btcRelayContract.abi, provider);
        this.contractInterface = new utils_1.Interface(btcRelayContract_1.btcRelayContract.abi);
        this.bitcoinRpc = bitcoinRpc;
    }
    retrieveLogAndBlockheight(blockData, requiredBlockheight) {
        return __awaiter(this, void 0, void 0, function* () {
            let storedHeader = null;
            const highScoreAndBlockHeight = yield this.contract._highScoreAndBlockHeight();
            const blockHeight = highScoreAndBlockHeight.shr(224).toNumber();
            if (blockHeight < blockData.height) {
                //Btc relay not synchronized to required blockheight
                console.log("not synchronized to block's height");
                return null;
            }
            if (requiredBlockheight != null) {
                if (blockHeight < requiredBlockheight) {
                    //Btc relay not synchronized to required blockheight
                    console.log("not synchronized to required blockheight");
                    return null;
                }
            }
            let currentBlock = (yield this.provider.provider.getBlockNumber()) - 1;
            while (storedHeader == null) {
                const params = {
                    address: this.contract.address,
                    fromBlock: currentBlock - limit,
                    toBlock: currentBlock
                };
                console.log("getLogs params: ", params);
                const logs = yield this.provider.provider.getLogs(params);
                for (let i = logs.length - 1; i >= 0; i--) {
                    const log = logs[i];
                    const parsedLog = this.contractInterface.parseLog(log);
                    if (parsedLog.name === "StoreHeader" || parsedLog.name === "StoreFork") {
                        const reversedBlockHash = parsedLog.args.blockHash.substring(2); //Strip 0x
                        const commitHash = parsedLog.args.commitmentHash;
                        const blockHash = Buffer.from(reversedBlockHash, "hex").reverse().toString("hex");
                        if (blockHash === blockData.blockhash) {
                            storedHeader = new EVMBtcStoredHeader_1.EVMBtcStoredHeader(parsedLog.args.storedHeader);
                            //Is it part of the main chain?
                            const blockHeight = storedHeader.getBlockheight();
                            const committedData = yield this.contract.getCommitment(ethers_1.BigNumber.from(blockHeight));
                            if (committedData !== commitHash) {
                                return null;
                            }
                            break;
                        }
                    }
                }
                currentBlock -= limit;
                if (storedHeader == null) {
                    yield new Promise(resolve => {
                        setTimeout(resolve, 500);
                    });
                }
            }
            return {
                header: storedHeader,
                height: blockHeight
            };
        });
    }
    retrieveLogByCommitHash(spvCommitmentHashStr, blockData) {
        return __awaiter(this, void 0, void 0, function* () {
            //Retrieve the log
            let storedHeader = null;
            const highScoreAndBlockHeight = yield this.contract._highScoreAndBlockHeight();
            const blockHeight = highScoreAndBlockHeight.shr(224).toNumber();
            if (blockHeight < blockData.height) {
                //Btc relay not synchronized to required blockheight
                console.log("not synchronized to block's height");
                return null;
            }
            const committedData = (yield this.contract.getCommitment(ethers_1.BigNumber.from(blockHeight))).substring(2);
            if (committedData !== spvCommitmentHashStr) {
                return null;
            }
            let currentBlock = (yield this.provider.provider.getBlockNumber()) - 1;
            while (storedHeader == null) {
                const params = {
                    address: this.contract.address,
                    fromBlock: currentBlock - limit,
                    toBlock: currentBlock
                };
                console.log("getLogs params: ", params);
                const logs = yield this.provider.provider.getLogs(params);
                for (let log of logs) {
                    const parsedLog = this.contractInterface.parseLog(log);
                    if (parsedLog.name === "StoreHeader" || parsedLog.name === "StoreFork") {
                        const reversedBlockHash = parsedLog.args.blockHash.substring(2); //Strip 0x
                        const commitHash = parsedLog.args.commitmentHash.substring(2);
                        const blockHash = Buffer.from(reversedBlockHash, "hex").reverse().toString("hex");
                        if (commitHash === spvCommitmentHashStr) {
                            if (blockHash !== blockData.blockhash) {
                                console.log("Invalid blockhash");
                                return null;
                            }
                            storedHeader = new EVMBtcStoredHeader_1.EVMBtcStoredHeader(parsedLog.args.storedHeader);
                            break;
                        }
                    }
                }
                currentBlock -= limit;
                if (storedHeader == null) {
                    yield new Promise(resolve => {
                        setTimeout(resolve, 500);
                    });
                }
            }
            return storedHeader;
        });
    }
    retrieveLatestKnownBlockLog() {
        return __awaiter(this, void 0, void 0, function* () {
            let storedHeader = null;
            let bitcoinHeader = null;
            let currentBlock = (yield this.provider.provider.getBlockNumber()) - 1;
            while (storedHeader == null) {
                const params = {
                    address: this.contract.address,
                    fromBlock: currentBlock - limit,
                    toBlock: currentBlock
                };
                console.log("getLogs params: ", params);
                const logs = yield this.provider.provider.getLogs(params);
                for (let i = logs.length - 1; i >= 0; i--) {
                    const log = logs[i];
                    const parsedLog = this.contractInterface.parseLog(log);
                    if (parsedLog.name === "StoreHeader" || parsedLog.name === "StoreFork") {
                        const reversedBlockHash = parsedLog.args.blockHash.substring(2); //Strip 0x
                        const commitHash = parsedLog.args.commitmentHash;
                        const blockHash = Buffer.from(reversedBlockHash, "hex").reverse().toString("hex");
                        const isInMainChain = yield this.bitcoinRpc.isInMainChain(blockHash);
                        if (isInMainChain) {
                            const _storedHeader = new EVMBtcStoredHeader_1.EVMBtcStoredHeader(parsedLog.args.storedHeader);
                            //Check if this header is part of main chain in btcrelay
                            const blockHeight = _storedHeader.getBlockheight();
                            const committedData = yield this.contract.getCommitment(ethers_1.BigNumber.from(blockHeight));
                            if (committedData === commitHash) {
                                bitcoinHeader = yield this.bitcoinRpc.getBlockHeader(blockHash);
                                storedHeader = _storedHeader;
                                break;
                            }
                        }
                    }
                }
                currentBlock -= limit;
                if (storedHeader == null) {
                    yield new Promise(resolve => {
                        setTimeout(resolve, 500);
                    });
                }
            }
            return {
                resultStoredHeader: storedHeader,
                resultBitcoinHeader: bitcoinHeader
            };
        });
    }
    static serializeBlockHeader(e) {
        return new EVMBtcHeader_1.EVMBtcHeader({
            version: e.getVersion(),
            reversedPrevBlockhash: Buffer.from(e.getPrevBlockhash(), "hex").reverse(),
            merkleRoot: Buffer.from(e.getMerkleRoot(), "hex").reverse(),
            timestamp: e.getTimestamp(),
            nbits: e.getNbits(),
            nonce: e.getNonce(),
            hash: Buffer.from(e.getHash(), "hex").reverse()
        });
    }
    saveMainHeaders(mainHeaders, storedHeader) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockHeaderObj = mainHeaders.map(EVMBtcRelay.serializeBlockHeader);
            //console.log("[EVMBtcRelay: saveMainHeaders] Block headers to submit: ", blockHeaderObj);
            const unsignedTx = yield this.contract.populateTransaction.submitMainChainHeaders("0x" + Buffer.concat(blockHeaderObj.map(e => e.serialize())).toString("hex"), storedHeader);
            unsignedTx.gasLimit = ethers_1.BigNumber.from(40000 + (40000 * mainHeaders.length));
            //console.log("[EVMBtcRelay: saveMainHeaders] TX created");
            const computedCommitedHeaders = [storedHeader];
            for (let blockHeader of blockHeaderObj) {
                //console.log("[EVMBtcRelay: saveMainHeaders] StoredHeaders pre-compute height: ", computedCommitedHeaders[computedCommitedHeaders.length-1].getBlockheight());
                computedCommitedHeaders.push(computedCommitedHeaders[computedCommitedHeaders.length - 1].computeNext(blockHeader));
            }
            //console.log("[EVMBtcRelay: saveMainHeaders] StoredHeaders pre-computed");
            return {
                forkId: 0,
                lastStoredHeader: computedCommitedHeaders[computedCommitedHeaders.length - 1],
                tx: unsignedTx,
                computedCommitedHeaders
            };
        });
    }
    saveNewForkHeaders(forkHeaders, storedHeader, tipWork) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockHeaderObj = forkHeaders.map(EVMBtcRelay.serializeBlockHeader);
            let forkId = yield this.contract._forkCounter();
            const unsignedTx = yield this.contract.populateTransaction.submitNewForkChainHeaders("0x" + Buffer.concat(blockHeaderObj.map(e => e.serialize())).toString("hex"), storedHeader);
            unsignedTx.gasLimit = ethers_1.BigNumber.from(200000 + (100000 * forkHeaders.length));
            const computedCommitedHeaders = [storedHeader];
            for (let blockHeader of blockHeaderObj) {
                computedCommitedHeaders.push(computedCommitedHeaders[computedCommitedHeaders.length - 1].computeNext(blockHeader));
            }
            const changedCommitedHeader = computedCommitedHeaders[computedCommitedHeaders.length - 1];
            if (crosslightning_base_1.StatePredictorUtils.gtBuffer(changedCommitedHeader.getChainWork(), tipWork)) {
                //Already main chain
                forkId = ethers_1.BigNumber.from(0);
            }
            return {
                forkId: forkId.toNumber(),
                lastStoredHeader: changedCommitedHeader,
                tx: unsignedTx,
                computedCommitedHeaders
            };
        });
    }
    saveForkHeaders(forkHeaders, storedHeader, forkId, tipWork) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockHeaderObj = forkHeaders.map(EVMBtcRelay.serializeBlockHeader);
            const unsignedTx = yield this.contract.populateTransaction.submitForkChainHeaders("0x" + Buffer.concat(blockHeaderObj.map(e => e.serialize())).toString("hex"), ethers_1.BigNumber.from(forkId), storedHeader);
            unsignedTx.gasLimit = ethers_1.BigNumber.from(200000 + (100000 * forkHeaders.length));
            const computedCommitedHeaders = [storedHeader];
            for (let blockHeader of blockHeaderObj) {
                computedCommitedHeaders.push(computedCommitedHeaders[computedCommitedHeaders.length - 1].computeNext(blockHeader));
            }
            const changedCommitedHeader = computedCommitedHeaders[computedCommitedHeaders.length - 1];
            if (crosslightning_base_1.StatePredictorUtils.gtBuffer(changedCommitedHeader.getChainWork(), tipWork)) {
                //Already main chain
                forkId = 0;
            }
            return {
                forkId: forkId,
                lastStoredHeader: changedCommitedHeader,
                tx: unsignedTx,
                computedCommitedHeaders
            };
        });
    }
    getTipData() {
        return __awaiter(this, void 0, void 0, function* () {
            const spvTipCommitment = yield this.contract.getLatestMainChainCommitmentHash();
            const highScoreAndBlockHeight = yield this.contract._highScoreAndBlockHeight();
            const chainWork = Buffer.from(highScoreAndBlockHeight.and(ethers_1.BigNumber.from("0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).toHexString().substring(2).padStart(64, "0"), "hex");
            return {
                commitHash: spvTipCommitment.substring(2),
                chainWork,
                blockheight: highScoreAndBlockHeight.shr(224).toNumber()
            };
        });
    }
}
exports.EVMBtcRelay = EVMBtcRelay;
