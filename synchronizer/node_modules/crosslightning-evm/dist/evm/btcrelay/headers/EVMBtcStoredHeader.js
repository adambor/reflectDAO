"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMBtcStoredHeader = void 0;
const EVMBtcHeader_1 = require("./EVMBtcHeader");
const ethers_1 = require("ethers");
const dist_1 = require("crosslightning-base/dist");
function reverseBigNumber(num) {
    const buffer = Buffer.alloc(4);
    buffer.writeUint32LE(num.toNumber());
    return ethers_1.BigNumber.from("0x" + buffer.toString("hex"));
}
class EVMBtcStoredHeader {
    constructor(obj) {
        this.chainWork = obj.chainWork;
        this.reversedPrevBlockHash = obj.reversedPrevBlockHash;
        this.merkleRoot = obj.merkleRoot;
        this.data1 = obj.data1;
        this.data2 = obj.data2;
    }
    getChainWork() {
        return Buffer.from(this.chainWork.toHexString().substring(2).padStart(64, "0"), "hex");
    }
    getHeader() {
        const version = reverseBigNumber(this.data1.shr(224).and(ethers_1.BigNumber.from(0xFFFFFFFF)));
        const nbits = reverseBigNumber(this.data1.shr(192).and(ethers_1.BigNumber.from(0xFFFFFFFF)));
        const nonce = reverseBigNumber(this.data1.shr(160).and(ethers_1.BigNumber.from(0xFFFFFFFF)));
        const timestamp = this.data2.and(ethers_1.BigNumber.from(0xFFFFFFFF));
        return new EVMBtcHeader_1.EVMBtcHeader({
            version: version.toNumber(),
            reversedPrevBlockhash: Buffer.from(this.reversedPrevBlockHash.substring(2), "hex"),
            merkleRoot: Buffer.from(this.merkleRoot.substring(2), "hex"),
            timestamp: timestamp.toNumber(),
            nbits: nbits.toNumber(),
            nonce: nonce.toNumber()
        });
    }
    getLastDiffAdjustment() {
        return this.data1.shr(128).and(ethers_1.BigNumber.from(0xFFFFFFFF)).toNumber();
    }
    getBlockheight() {
        return this.data1.shr(96).and(ethers_1.BigNumber.from(0xFFFFFFFF)).toNumber();
    }
    getPrevBlockTimestamps() {
        const arr = [];
        for (let i = 64; i >= 0; i -= 32) {
            arr.push(this.data1.shr(i).and(ethers_1.BigNumber.from(0xFFFFFFFF)).toNumber());
        }
        for (let i = 224; i >= 32; i -= 32) {
            arr.push(this.data2.shr(i).and(ethers_1.BigNumber.from(0xFFFFFFFF)).toNumber());
        }
        return arr;
    }
    computeNext(header) {
        //console.log("[EVMBtcStoredHeader] Compute next with header: ", header);
        const blockheight = this.getBlockheight() + 1;
        const prevBlockTimestamps = this.getPrevBlockTimestamps();
        //console.log("[EVMBtcStoredHeader: computeNext] Timestamps: ", prevBlockTimestamps);
        for (let i = 1; i < 10; i++) {
            prevBlockTimestamps[i - 1] = prevBlockTimestamps[i];
        }
        const currentHeader = this.getHeader();
        //console.log("[EVMBtcStoredHeader: computeNext] Current header: ", header);
        prevBlockTimestamps[9] = currentHeader.getTimestamp();
        let lastDiffAdjustment = this.getLastDiffAdjustment();
        if (blockheight % dist_1.StatePredictorUtils.DIFF_ADJUSTMENT_PERIOD === 0) {
            lastDiffAdjustment = header.timestamp;
        }
        //console.log("[EVMBtcStoredHeader: computeNext] Computing difficulty...");
        const difficulty = dist_1.StatePredictorUtils.getDifficulty(header.nbits);
        const diffNum = ethers_1.BigNumber.from("0x" + difficulty.toString("hex"));
        //console.log("[EVMBtcStoredHeader: computeNext] Difficulty computed: ", diffNum.toHexString());
        const data1 = reverseBigNumber(ethers_1.BigNumber.from(header.version)).and(ethers_1.BigNumber.from("0xFFFFFFFF")).shl(224)
            .or(reverseBigNumber(ethers_1.BigNumber.from(header.nbits)).and(ethers_1.BigNumber.from("0xFFFFFFFF")).shl(192))
            .or(reverseBigNumber(ethers_1.BigNumber.from(header.nonce)).and(ethers_1.BigNumber.from("0xFFFFFFFF")).shl(160))
            .or(ethers_1.BigNumber.from(lastDiffAdjustment).and(ethers_1.BigNumber.from("0xFFFFFFFF")).shl(128))
            .or(ethers_1.BigNumber.from(blockheight).and(ethers_1.BigNumber.from("0xFFFFFFFF")).shl(96))
            .or(ethers_1.BigNumber.from(prevBlockTimestamps[0]).and(ethers_1.BigNumber.from("0xFFFFFFFF")).shl(64))
            .or(ethers_1.BigNumber.from(prevBlockTimestamps[1]).and(ethers_1.BigNumber.from("0xFFFFFFFF")).shl(32))
            .or(ethers_1.BigNumber.from(prevBlockTimestamps[2]).and(ethers_1.BigNumber.from("0xFFFFFFFF")));
        let data2 = ethers_1.BigNumber.from(0);
        for (let i = 0; i < 7; i++) {
            data2 = data2.or(ethers_1.BigNumber.from(prevBlockTimestamps[3 + i]).and("0xFFFFFFFF").shl((7 - i) * 32));
        }
        data2 = data2.or(ethers_1.BigNumber.from(header.timestamp).and("0xFFFFFFFF"));
        return new EVMBtcStoredHeader({
            chainWork: this.chainWork.add(diffNum),
            reversedPrevBlockHash: "0x" + header.reversedPrevBlockhash.toString("hex"),
            merkleRoot: "0x" + header.merkleRoot.toString("hex"),
            data1,
            data2
        });
    }
}
exports.EVMBtcStoredHeader = EVMBtcStoredHeader;
